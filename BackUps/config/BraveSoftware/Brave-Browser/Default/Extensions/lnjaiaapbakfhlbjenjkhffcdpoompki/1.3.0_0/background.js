var background=function(){"use strict";var Te,Ee,Se,Pe,Ce,_e,Me,Le,$e,Re,je;function Fe(e){return e==null||typeof e=="function"?{main:e}:e}const Ne=/^(https?|wss?|file|ftp|\*):\/\/(\*|\*\.[^*/]+|[^*/]+)\/.*$|^file:\/\/\/.*$|^resource:\/\/(\*|\*\.[^*/]+|[^*/]+)\/.*$|^about:/,Q=(Te=globalThis.navigator)==null?void 0:Te.userAgent.includes("Firefox/"),X=Q?/^(https?|wss?):[/][/][^/]+([/].*)?$/:/^https?:[/][/][^/]+([/].*)?$/,Y=/^(https?|file|ftp):[/]+/;function Be(e){if(!Ue(e))throw new Error(e+" is an invalid pattern. See https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Match_patterns for more info.")}function Ue(e){return e==="<all_urls>"||Ne.test(e)}function ze(e,...n){if(n.includes("<all_urls>")&&Y.test(e)||n.includes("*://*/*")&&X.test(e))return!0;for(const r of n)if(C(r).test(e))return!0;return!1}function Ie(e,...n){return n.filter(r=>ze(e,r))}function De(e){Be(e);let[,n,r="",s]=e.split(/(^[^:]+:[/][/])([^/]+)?/);return n=n.replace("*",Q?"(https?|wss?)":"https?").replaceAll(/[/]/g,"[/]"),r==="*"&&(r="[^/]+"),r&&(r=r.replace(/^[*][.]/,"([^/]+.)*").replaceAll(/[.]/g,"[.]").replace(/[*]$/,"[^.]+")),s=s.replaceAll(/[/]/g,"[/]").replaceAll(/[.]/g,"[.]").replaceAll(/[*]/g,".*"),"^"+n+r+"("+s+")?$"}function C(...e){return e.length===0?/$./:e.includes("<all_urls>")?Y:e.includes("*://*/*")?X:new RegExp(e.map(n=>De(n)).join("|"))}function ee(e){return e.includes("<all_urls>")?["<all_urls>"]:e.includes("*://*/*")?["*://*/*"]:e.filter(n=>!e.some(r=>n!==r&&C(r).test(n)))}function We(e=chrome.runtime.getManifest()){var s;const n={origins:[],permissions:[]},r=new Set([...e.permissions??[],...e.host_permissions??[],...(e.content_scripts??[]).flatMap(t=>t.matches??[])]);e.devtools_page&&!((s=e.optional_permissions)!=null&&s.includes("devtools"))&&r.add("devtools");for(const t of r)t.includes("://")||t==="<all_urls>"?n.origins.push(t):n.permissions.push(t);return Ze(n)}const qe=/:[/][/][*.]*([^/]+)/;function ne(e){return e.split(qe)[1]}async function Ve(e){return new Promise(n=>{chrome.permissions.getAll(r=>{n(He(r,e))})})}function He(e,{manifest:n,strictOrigins:r=!0}={}){const s=We(n),t={origins:[],permissions:[]};for(const i of e.origins??[])if(!s.origins.includes(i)){if(!r){const c=ne(i);if(s.origins.some(d=>ne(d)===c))continue}t.origins.push(i)}for(const i of e.permissions??[])s.permissions.includes(i)||t.permissions.push(i);return t}function Ze({origins:e,permissions:n}){return{origins:e?ee(e):[],permissions:n?[...n]:[]}}function re(e){if(!e)return!1;try{const{pathname:n}=new URL(e,location.origin);return n===location.pathname}catch{return!1}}function z(e){var n,r,s;return(s=(r=(n=globalThis.chrome)==null?void 0:n.runtime)==null?void 0:r.getManifest)==null?void 0:s.call(r)}function te(e){let n;return()=>(n===void 0&&(n=e()),n)}const Ge=te(()=>{var n,r;const e=z();return e&&re(e.background_page??((n=e.background)==null?void 0:n.page))?!0:!!((r=e==null?void 0:e.background)!=null&&r.scripts&&re("/_generated_background_page.html"))}),Je=te(()=>{var e,n,r;return Ge()&&((e=z())==null?void 0:e.manifest_version)===2&&((r=(n=z())==null?void 0:n.background)==null?void 0:r.persistent)!==!1}),Ke=()=>{var e;return(e=globalThis.navigator)==null?void 0:e.userAgent.includes("Chrome")},I="__webext-events__startup",L=new EventTarget;let se=!1,ie=!1;const $=((Ee=globalThis.browser)==null?void 0:Ee.storage)??((Se=globalThis.chrome)==null?void 0:Se.storage);async function Qe(){if(se=!0,!ie)return;if(Je()){L.dispatchEvent(new Event("extension-start"));return}if(!($!=null&&$.session)){Ke()&&chrome.runtime.getManifest().manifest_version===2?console.warn("onExtensionStart is unable to determine whether it’s being run for the first time on MV2 Event Pages in Chrome. It will run the listeners anyway."):console.warn("onExtensionStart is unable to determine whether it’s being run for the first time without the `storage` permission. It will run the listeners anyway"),L.dispatchEvent(new Event("extension-start"));return}const e=await $.session.get(I);I in e||(await $.session.set({[I]:!0}),L.dispatchEvent(new Event("extension-start")))}const Xe=Object.freeze({addListener(e){se?console.warn("onExtensionStart.addListener() was called after the extension started. The callback will not be called."):(ie=!0,L.addEventListener("extension-start",e))},removeListener(e){L.removeEventListener("extension-start",e)}});setTimeout(Qe,2);async function Ye(e,{filter:n,signal:r}={}){r!=null&&r.aborted||await new Promise(s=>{const t=(...i)=>{(!n||n(...i))&&(s(),e.removeListener(t))};e.addListener(t),r==null||r.addEventListener("abort",()=>{s(),e.removeListener(t)})})}function en(e){return JSON.stringify([e.all_frames,e.exclude_matches,e.run_at])}function nn(e,{warn:n=!0}={}){const r=new Map,s=(t,i)=>t?t.filter(c=>{const u=en(i);return r.has(c)?(n&&u!==r.get(c)&&console.warn(`Duplicate file in the manifest content_scripts: ${c} 
More info: https://github.com/fregante/webext-dynamic-content-scripts/issues/62`),!1):(r.set(c,u),!0)}):[];return e.flatMap(t=>{const{matches:i,...c}=t,u={...c,js:s(t.js,t),css:s(t.css,t)};return u.css.length+u.js.length===0?[]:u})}function oe(e){return new Proxy(e,{get(n,r){if(n[r])return typeof n[r]!="function"?new oe(n[r]):(...s)=>new Promise((t,i)=>{n[r](...s,c=>{chrome.runtime.lastError?i(new Error(chrome.runtime.lastError.message)):t(c)})})}})}const y=globalThis.chrome&&new oe(globalThis.chrome),ae=!!((Pe=globalThis.chrome)!=null&&Pe.scripting);function rn(e){return typeof e=="object"?{...e,allFrames:!1}:{tabId:e,frameId:void 0,allFrames:!0}}function ce(e){return Array.isArray(e)?e:[e]}function le(e){return e===void 0?void 0:[e]}async function tn({tabId:e,frameId:n,files:r,allFrames:s,matchAboutBlank:t,runAt:i},{ignoreTargetErrors:c}={}){const u=Promise.all(r.map(async d=>(typeof d=="string"&&(d={file:d}),ae?chrome.scripting.insertCSS({target:{tabId:e,frameIds:le(n),allFrames:n===void 0?s:void 0},files:"file"in d?[d.file]:void 0,css:"code"in d?d.code:void 0}):y.tabs.insertCSS(e,{...d,matchAboutBlank:t,allFrames:s,frameId:n,runAt:i??"document_start"}))));c?await D(u):await u}function sn(e){if(e.some(n=>"code"in n))throw new Error("chrome.scripting does not support injecting strings of `code`")}async function on({tabId:e,frameId:n,files:r,allFrames:s,matchAboutBlank:t,runAt:i},{ignoreTargetErrors:c}={}){const u=r.map(h=>typeof h=="string"?{file:h}:h);if(ae){sn(u);const h=chrome.scripting.executeScript({target:{tabId:e,frameIds:le(n),allFrames:n===void 0?s:void 0},files:u.map(({file:T})=>T)});c?await D(h):await h;return}const d=[];for(const h of u)"code"in h&&await d.at(-1),d.push(y.tabs.executeScript(e,{...h,matchAboutBlank:t,allFrames:s,frameId:n,runAt:i}));c?await D(Promise.all(d)):await Promise.all(d)}async function an(e,n){if(e.length===0)return[];const r=n?C(...n):void 0;return(await y.tabs.query({url:e})).filter(t=>t.id&&t.url&&(r?!r.test(t.url):!0)).map(t=>t.id)}async function ge(e,n,r={}){const s=ce(e);await Promise.all(s.map(async t=>cn(rn(t),n,r)))}async function cn({frameId:e,tabId:n,allFrames:r},s,t={}){const i=ce(s).flatMap(c=>[tn({tabId:n,frameId:e,allFrames:r,files:c.css??[],matchAboutBlank:c.matchAboutBlank??c.match_about_blank,runAt:c.runAt??c.run_at},t),on({tabId:n,frameId:e,allFrames:r,files:c.js??[],matchAboutBlank:c.matchAboutBlank??c.match_about_blank,runAt:c.runAt??c.run_at},t)]);await Promise.all(i)}const ln=/^No frame with id \d+ in tab \d+.$|^No tab with id: \d+.$|^The tab was closed.$|^The frame was removed.$/;async function D(e){try{await e}catch(n){if(!ln.test(n==null?void 0:n.message))throw n}}async function gn(e,n){const r=n.flatMap(s=>s.matches??[]);return ge(await an(e,r),n,{ignoreTargetErrors:!0})}const mn="Type error for parameter contentScriptOptions (Error processing matches: Array requires at least 1 items; you have 0) for contentScripts.register.",un="Permission denied to register a content script for ",W=typeof chrome=="object"&&"webNavigation"in chrome;async function dn(e){return y.permissions.contains({origins:[new URL(e).origin+"/*"]})}async function fn(e,n){const{js:r=[],css:s=[],matchAboutBlank:t,matches:i=[],excludeMatches:c,runAt:u}=e;let{allFrames:d}=e;if(W?d=!1:d&&console.warn("`allFrames: true` requires the `webNavigation` permission to work correctly: https://github.com/fregante/content-scripts-register-polyfill#permissions"),i.length===0)throw new Error(mn);await Promise.all(i.map(async p=>{if(!await y.permissions.contains({origins:[p]}))throw new Error(un+p)}));const h=C(...i),T=C(...c??[]),U=async(p,P,k=0)=>{!h.test(p)||T.test(p)||!await dn(p)||await ge({tabId:P,frameId:k},{css:s,js:r,matchAboutBlank:t,runAt:u},{ignoreTargetErrors:!0})},R=async(p,{status:P},{url:k})=>{P==="loading"&&k&&U(k,p)},S=async({tabId:p,frameId:P,url:k})=>{U(k,p,P)};return W?chrome.webNavigation.onCommitted.addListener(S):chrome.tabs.onUpdated.addListener(R),{async unregister(){W?chrome.webNavigation.onCommitted.removeListener(S):chrome.tabs.onUpdated.removeListener(R)}}}const me=(_e=(Ce=globalThis.chrome)==null?void 0:Ce.scripting)==null?void 0:_e.registerContentScripts,ue=(Le=(Me=globalThis.browser)==null?void 0:Me.contentScripts)==null?void 0:Le.register;async function An(e){var r,s;if(me){const t="webext-dynamic-content-script-"+JSON.stringify(e);try{await me([{...e,id:t}])}catch(i){if(!(i!=null&&i.message.startsWith("Duplicate script ID")))throw i}return{unregister:async()=>chrome.scripting.unregisterContentScripts({ids:[t]})}}const n={...e,js:(r=e.js)==null?void 0:r.map(t=>({file:t})),css:(s=e.css)==null?void 0:s.map(t=>({file:t}))};return ue?ue(n):fn(n)}const de=new Map;function fe(e){return new URL(e,location.origin).pathname}function hn(){const{content_scripts:e,manifest_version:n}=chrome.runtime.getManifest();if(!e)throw new Error("webext-dynamic-content-scripts tried to register scripts on the new host permissions, but no content scripts were found in the manifest.");return nn(e,{warn:n===2})}async function pn(e,n){var r,s;if(e.length!==0)for(const t of e)for(const i of n){const c=An({js:(r=i.js)==null?void 0:r.map(u=>fe(u)),css:(s=i.css)==null?void 0:s.map(u=>fe(u)),allFrames:i.all_frames,matches:[t],excludeMatches:i.matches,runAt:i.run_at});de.set(t,c)}}async function xn({origins:e}){await Ae(e)}async function bn({origins:e}){if(e!=null&&e.length)for(const[n,r]of de)e.includes(n)&&(await r).unregister()}async function Ae(e){if(!(e!=null&&e.length))return;const n=hn();await Promise.all([gn(e,n),pn(e,n)])}async function wn(){const{origins:e}=await Ve({strictOrigins:!1});await Ae(e)}function yn(){chrome.permissions.onRemoved.addListener(bn),chrome.permissions.onAdded.addListener(xn),Xe.addListener(wn)}yn();function q(e){if(!e)return!1;try{const{pathname:n}=new URL(e,location.origin);return n===location.pathname}catch{return!1}}function he(e){var n,r,s;return(s=(r=(n=globalThis.chrome)==null?void 0:n.runtime)==null?void 0:r.getManifest)==null?void 0:s.call(r)}function pe(e){let n;return()=>(n===void 0&&(n=e()),n)}const vn=()=>xe()||be(),xe=pe(()=>{var n,r;const e=he();return e?q(e.background_page??((n=e.background)==null?void 0:n.page))?!0:!!((r=e.background)!=null&&r.scripts&&q("/_generated_background_page.html")):!1}),be=pe(()=>{var e,n;return q((n=(e=he())==null?void 0:e.background)==null?void 0:n.service_worker)}),we=()=>{var e;return(e=globalThis.navigator)==null?void 0:e.userAgent.includes("Chrome")};function kn(e=chrome.runtime.getManifest()){var s;const n={origins:[],permissions:[]},r=new Set([...e.permissions??[],...e.host_permissions??[],...(e.content_scripts??[]).flatMap(t=>t.matches??[])]);e.devtools_page&&!((s=e.optional_permissions)!=null&&s.includes("devtools"))&&r.add("devtools");for(const t of r)t.includes("://")||t==="<all_urls>"?n.origins.push(t):n.permissions.push(t);return En(n)}function Tn(e,n=chrome.runtime.getManifest()){const r=kn(n);return C(...r.origins).test(e)}function En({origins:e,permissions:n}){return{origins:e?ee(e):[],permissions:n?[...n]:[]}}const Sn=!!(($e=globalThis.chrome)!=null&&$e.scripting);function Pn(e){return typeof e=="object"?e:{tabId:e,frameId:0}}const Cn=/^function \w+\(\) {[\n\s]+\[native code][\n\s]+}/;async function V(e,n,...r){if(Cn.test(String(n)))throw new TypeError("Native functions need to be wrapped first, like `executeFunction(1, () => alert(1))`");const{frameId:s,tabId:t}=Pn(e);if(Sn){const[c]=await chrome.scripting.executeScript({target:{tabId:t,frameIds:[s]},func:n,args:r});return c==null?void 0:c.result}const[i]=await y.tabs.executeScript(t,{code:`(${n.toString()})(...${JSON.stringify(r)})`,matchAboutBlank:!0,frameId:s});return i}const _n=["chrome.google.com/webstore","chromewebstore.google.com","accounts-static.cdn.mozilla.net","accounts.firefox.com","addons.cdn.mozilla.net","addons.mozilla.org","api.accounts.firefox.com","content.cdn.mozilla.net","discovery.addons.mozilla.org","input.mozilla.org","install.mozilla.org","oauth.accounts.firefox.com","profile.accounts.firefox.com","support.mozilla.org","sync.services.mozilla.com","testpilot.firefox.com"];function ye(e){if(!(e!=null&&e.startsWith("http")))return!1;const n=e.replace(/^https?:\/\//,"");return _n.every(r=>!n.startsWith(r))}function Mn(e){return typeof e=="object"?e:{tabId:e,frameId:0}}async function H(e){const{frameId:n,tabId:r}=Mn(e);try{if(n===0&&"tabs"in globalThis.chrome){const s=await y.tabs.get(r);if(s.url)return s.url}return await V(e,()=>location.href)}catch{return}}const ve=new Map;function Ln(e){return e.includes("Cannot create item with duplicate id")||e.includes("already exists in menus.create")}function $n(){var n;if(!((n=chrome.runtime.getManifest().permissions)!=null&&n.includes("contextMenus"))&&!/Android.+Firefox\//.test(navigator.userAgent))throw new Error("webext-permission-toggle requires the `contextMenus` permission");console.warn("chrome.contextMenus is not available")}function Rn(e,n){var r;(r=ve.get(e.menuItemId))==null||r(e,n)}async function jn(e){const{onclick:n,...r}=e;if(!chrome.contextMenus){$n();return}n&&(chrome.contextMenus.onClicked.addListener(Rn),ve.set(r.id,n));const{id:s,...t}=r,[,i]=await Promise.allSettled([y.contextMenus.update(s,t),y.contextMenus.create(r)]);if(i.status==="rejected"&&!Ln(String(i.reason)))throw i.reason}async function On(e){await Ye(chrome.windows.onRemoved,{filter:n=>n===e})}function Fn(){const e=document.querySelector("button");e.addEventListener("click",n=>{window.close()}),window.addEventListener("blur",n=>{window.close()}),window.resizeBy(0,document.body.scrollHeight-window.innerHeight),window.moveTo((screen.width-window.outerWidth)/2,(screen.height-window.outerHeight)/2),e.focus()}const Nn=`
	/*! https://npm.im/webext-base-css */

	/* Chrome only: -webkit-hyphens */
	/* Safari only: _::-webkit-full-page-media */

	/* webpackIgnore: true */
	@import url('chrome://global/skin/in-content/common.css') (min--moz-device-pixel-ratio:0); /* Firefox-only */

	:root {
		--background-color-for-chrome: #292a2d;
		max-width: 700px;
		margin: auto;
	}

	body {
		--body-margin-h: 8px;
		margin-left: var(--body-margin-h);
		margin-right: var(--body-margin-h);
	}

	/* Selector matches Firefox’ */
	input[type='number'],
	input[type='password'],
	input[type='search'],
	input[type='text'],
	input[type='url'],
	input:not([type]),
	textarea {
		display: block;
		box-sizing: border-box;
		margin-left: 0;
		width: 100%;
		resize: vertical;
		-moz-tab-size: 4 !important;
		tab-size: 4 !important;
	}

	input[type='checkbox'] {
		vertical-align: -0.15em;
	}

	@supports (not (-webkit-hyphens:none)) and (not (-moz-appearance:none)) and (list-style-type:'*') {
		textarea:focus {
			/* Inexplicably missing from Chrome’s input style https://github.com/chromium/chromium/blob/6bea0557fe/extensions/renderer/resources/extension.css#L287 */
			border-color: #4d90fe;
			transition: border-color 200ms;
		}
	}

	hr {
		margin-right: calc(-1 * var(--body-margin-h));
		margin-left: calc(-1 * var(--body-margin-h));
		border: none;
		border-bottom: 1px solid #aaa4;
	}

	img {
		vertical-align: middle;
	}

	_::-webkit-full-page-media,
	_:future,
	:root {
		font-family: -apple-system, BlinkMacSystemFont, sans-serif, 'Apple Color Emoji';
	}

	_::-webkit-full-page-media,
	_:future,
	input[type='number'],
	input[type='password'],
	input[type='search'],
	input[type='text'],
	input[type='url'],
	input:not([type]),
	textarea {
		border: solid 1px #888;
		padding: 0.4em;
		font: inherit;
		-webkit-appearance: none;
	}

	@media (prefers-color-scheme: dark) {
		:root {
			color-scheme: dark;
			background-color: var(--background-color-for-chrome);
		}

		body,
		h3 { /* Chrome #3 */
			color: #e8eaed;
		}

		a {
			color: var(--link-color, #8ab4f8);
		}

		a:active {
			color: var(--link-color-active, #b6d3f9);
		}

		input[type='number'],
		input[type='password'],
		input[type='search'],
		input[type='text'],
		input[type='url'],
		input:not([type]),
		textarea {
			color: inherit;
			background-color: transparent;
		}
	}

	/* End webext-base-css */

	body {
		box-sizing: border-box;
		min-height: 100vh;
		margin: 0;
		padding: 1em;
		justify-content: center;
		display: flex;
		flex-direction: column;
		font-size: 14px;
		line-height: 1.5;
		font-family: system, system-ui, sans-serif;
	}

	button {
		margin-top: 1em;
		margin-left: auto;
	}
`;function Bn(e=""){return`
		<!doctype html>
		<meta charset="utf-8" />
		<title>${chrome.runtime.getManifest().name}</title>
		<style>${Nn}</style>
		<script defer src="alert.js"><\/script>
		<body>
			<main>${e}</main>
			<button>Ok</button>
		</body>
		<script>(${Fn.toString()})()<\/script>
	`}function Un(e){const n=new URL("https://webext-alert.vercel.app/");return n.searchParams.set("message",e),n.searchParams.set("title",chrome.runtime.getManifest().name),n.href}async function ke(e){try{return await chrome.windows.create({type:"popup",focused:!0,url:e,height:150,width:420})}catch{}}async function zn(e){const n=await ke("data:text/html,"+encodeURIComponent(Bn(e)))??await ke(Un(e));n!=null&&n.id?await On(n.id):console.log(e)}const In=be()||!we()&&xe()?zn:globalThis.alert??console.log,Z="webext-permission-toggle:add-permission";let E;const _=we()&&((je=(Re=globalThis.chrome)==null?void 0:Re.runtime)==null?void 0:je.getManifest().manifest_version)<3?y:globalThis.chrome;function Dn(e){if(!(e!=null&&e.id))throw new Error("The browser didn't supply any information about the active tab.")}function Wn(e){if(!e)throw new Error("The browser didn't supply the current page's URL.")}function qn(e){if(!ye(e))throw new Error(chrome.runtime.getManifest().name+" can't be enabled on this page.")}async function Vn(e){return _.permissions.contains({origins:[e+"/*"]})}function F({checked:e,enabled:n}){chrome.contextMenus.update(Z,{checked:e,enabled:n})}async function N(e){if(!e){F({enabled:!0,checked:!1});return}if(ye(e)){const{origin:n}=new URL(e),r=Tn(e),s=await Vn(n);F({enabled:!r||!s,checked:s});return}F({enabled:!1,checked:!1})}async function Hn(e,n){const r={origins:[new URL(e).origin+"/*"]};if(n)await _.permissions.request(r);else{const{origins:s=[]}=await _.permissions.getAll(),t=Ie(e,...s);console.debug("Removing permissions:",...t),await _.permissions.remove({origins:t})}return _.permissions.contains(r)}async function Zn({tabId:e}){N(await H(e)??"")}async function Gn(e){const[n]=await _.tabs.query({active:!0,windowId:e});N(n==null?void 0:n.url)}async function Jn({checked:e,menuItemId:n},r){if(n!==Z)return;let s;try{Dn(r),s=r.url||await H(r.id),Wn(s),qn(s);const t=await Hn(s,e);t===e||F({checked:t}),t&&E.reloadOnSuccess&&V(r.id,c=>{confirm(c)&&location.reload()},E.reloadOnSuccess)}catch(t){if(setTimeout(N,500,s),r!=null&&r.id)try{await V(r.id,i=>{globalThis.alert(i)},String(t))}catch{In(String(t))}throw t}}function Kn(e){if(!vn())throw new Error("webext-permission-toggle can only be called from a background page");if(E)throw new Error("webext-permission-toggle can only be initialized once");const n=chrome.runtime.getManifest();E={title:`Enable ${n.name} on this domain`,reloadOnSuccess:!1,...e},E.reloadOnSuccess===!0&&(E.reloadOnSuccess=`Do you want to reload this page to apply ${n.name}?`);const r=[...n.optional_permissions??[],...n.optional_host_permissions??[]].filter(t=>t==="<all_urls>"||t.includes("*"));if(r.length===0)throw new TypeError("webext-permission-toggle requires some wildcard hosts to be specified in `optional_permissions` (MV2) or `optional_host_permissions` (MV3)");const s=n.manifest_version===2?["page_action","browser_action"]:["action"];chrome.contextMenus.onClicked.addListener(Jn),chrome.tabs.onActivated.addListener(Zn),chrome.windows.onFocusChanged.addListener(Gn),chrome.tabs.onUpdated.addListener(async(t,{status:i},{url:c,active:u})=>{u&&i==="complete"&&N(c??await H(t)??"")}),jn({id:Z,type:"checkbox",checked:!1,title:E.title,contexts:s,documentUrlPatterns:r})}const Qn=Fe({main(){Kn()}});function tr(){}var Xn=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},Yn={exports:{}};(function(e,n){(function(r,s){s(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:Xn,function(r){if(!(globalThis.chrome&&globalThis.chrome.runtime&&globalThis.chrome.runtime.id))throw new Error("This script should only be loaded in a browser extension.");if(globalThis.browser&&globalThis.browser.runtime&&globalThis.browser.runtime.id)r.exports=globalThis.browser;else{const s="The message port closed before a response was received.",t=i=>{const c={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(c).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class u extends WeakMap{constructor(a,g=void 0){super(g),this.createItem=a}get(a){return this.has(a)||this.set(a,this.createItem(a)),super.get(a)}}const d=o=>o&&typeof o=="object"&&typeof o.then=="function",h=(o,a)=>(...g)=>{i.runtime.lastError?o.reject(new Error(i.runtime.lastError.message)):a.singleCallbackArg||g.length<=1&&a.singleCallbackArg!==!1?o.resolve(g[0]):o.resolve(g)},T=o=>o==1?"argument":"arguments",U=(o,a)=>function(m,...A){if(A.length<a.minArgs)throw new Error(`Expected at least ${a.minArgs} ${T(a.minArgs)} for ${o}(), got ${A.length}`);if(A.length>a.maxArgs)throw new Error(`Expected at most ${a.maxArgs} ${T(a.maxArgs)} for ${o}(), got ${A.length}`);return new Promise((x,b)=>{if(a.fallbackToNoCallback)try{m[o](...A,h({resolve:x,reject:b},a))}catch(l){console.warn(`${o} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,l),m[o](...A),a.fallbackToNoCallback=!1,a.noCallback=!0,x()}else a.noCallback?(m[o](...A),x()):m[o](...A,h({resolve:x,reject:b},a))})},R=(o,a,g)=>new Proxy(a,{apply(m,A,x){return g.call(A,o,...x)}});let S=Function.call.bind(Object.prototype.hasOwnProperty);const j=(o,a={},g={})=>{let m=Object.create(null),A={has(b,l){return l in o||l in m},get(b,l,w){if(l in m)return m[l];if(!(l in o))return;let f=o[l];if(typeof f=="function")if(typeof a[l]=="function")f=R(o,o[l],a[l]);else if(S(g,l)){let M=U(l,g[l]);f=R(o,o[l],M)}else f=f.bind(o);else if(typeof f=="object"&&f!==null&&(S(a,l)||S(g,l)))f=j(f,a[l],g[l]);else if(S(g,"*"))f=j(f,a[l],g["*"]);else return Object.defineProperty(m,l,{configurable:!0,enumerable:!0,get(){return o[l]},set(M){o[l]=M}}),f;return m[l]=f,f},set(b,l,w,f){return l in m?m[l]=w:o[l]=w,!0},defineProperty(b,l,w){return Reflect.defineProperty(m,l,w)},deleteProperty(b,l){return Reflect.deleteProperty(m,l)}},x=Object.create(o);return new Proxy(x,A)},p=o=>({addListener(a,g,...m){a.addListener(o.get(g),...m)},hasListener(a,g){return a.hasListener(o.get(g))},removeListener(a,g){a.removeListener(o.get(g))}}),P=new u(o=>typeof o!="function"?o:function(g){const m=j(g,{},{getContent:{minArgs:0,maxArgs:0}});o(m)}),k=new u(o=>typeof o!="function"?o:function(g,m,A){let x=!1,b,l=new Promise(O=>{b=function(v){x=!0,O(v)}}),w;try{w=o(g,m,b)}catch(O){w=Promise.reject(O)}const f=w!==!0&&d(w);if(w!==!0&&!f&&!x)return!1;const M=O=>{O.then(v=>{A(v)},v=>{let K;v&&(v instanceof Error||typeof v.message=="string")?K=v.message:K="An unexpected error occurred",A({__mozWebExtensionPolyfillReject__:!0,message:K})}).catch(v=>{console.error("Failed to send onMessage rejected reply",v)})};return M(f?w:l),!0}),nr=({reject:o,resolve:a},g)=>{i.runtime.lastError?i.runtime.lastError.message===s?a():o(new Error(i.runtime.lastError.message)):g&&g.__mozWebExtensionPolyfillReject__?o(new Error(g.message)):a(g)},Oe=(o,a,g,...m)=>{if(m.length<a.minArgs)throw new Error(`Expected at least ${a.minArgs} ${T(a.minArgs)} for ${o}(), got ${m.length}`);if(m.length>a.maxArgs)throw new Error(`Expected at most ${a.maxArgs} ${T(a.maxArgs)} for ${o}(), got ${m.length}`);return new Promise((A,x)=>{const b=nr.bind(null,{resolve:A,reject:x});m.push(b),g.sendMessage(...m)})},rr={devtools:{network:{onRequestFinished:p(P)}},runtime:{onMessage:p(k),onMessageExternal:p(k),sendMessage:Oe.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:Oe.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},J={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return c.privacy={network:{"*":J},services:{"*":J},websites:{"*":J}},j(i,rr,c)};r.exports=t(chrome)}})})(Yn);function B(e,...n){}const er={debug:(...e)=>B(console.debug,...e),log:(...e)=>B(console.log,...e),warn:(...e)=>B(console.warn,...e),error:(...e)=>B(console.error,...e)};let G;try{G=Qn.main(),G instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(e){throw er.error("The background crashed on startup!"),e}return G}();
background;
